package main_test

import (
	main "a21hc3NpZ25tZW50"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

type TestData struct {
	Input    [][][2]int
	Expected []int
}

var _ = Describe("CountProfit", func() {
	When("Data is empty", func() {
		It("should return empty slice", func() {
			actual := main.CountProfit([][][2]int{})

			Expect(actual).To(Equal([]int{}))
			Expect(actual).To(BeEmpty())
		})
	})

	When("Data is countain only one branch with many month", func() {
		It("should return total profit in many month", func() {
			var testData = []TestData{
				{[][][2]int{{{1000, 500}, {500, 150}, {600, 100}, {800, 750}}}, []int{500, 350, 500, 50}},
				{[][][2]int{{{1000, 500}, {500, 150}, {600, 100}, {800, 750}, {600, 200}, {500, 150}, {1200, 300}, {1000, 750}, {1000, 500}, {500, 150}, {600, 100}, {800, 750}, {1000, 500}, {500, 150}, {600, 100}, {800, 750}, {500, 150}, {600, 100}, {800, 750}, {600, 200}, {500, 150}, {1200, 300}}}, []int{500, 350, 500, 50, 400, 350, 900, 250, 500, 350, 500, 50, 500, 350, 500, 50, 350, 500, 50, 400, 350, 900}},
			}

			for _, test := range testData {
				actual := main.CountProfit(test.Input)

				Expect(actual).NotTo(BeEmpty())
				Expect(actual).To(Equal(test.Expected))

			}
		})
	})

	When("Data is countain many branch only one month", func() {
		It("should return total profit in one month", func() {
			var testData = []TestData{
				{[][][2]int{{{1000, 200}}, {{500, 100}}, {{450, 150}}, {{100, 50}}}, []int{1550}},
				{[][][2]int{{{100, 20}}, {{500, 100}}, {{450, 150}}, {{100, 50}}, {{1000, 200}}, {{500, 200}}, {{200, 100}}, {{600, 500}}, {{200, 100}}, {{100, 20}}, {{500, 100}}, {{450, 150}}, {{100, 50}}, {{1000, 200}}, {{500, 200}}, {{200, 100}}, {{600, 500}}, {{200, 100}}, {{100, 20}}, {{500, 100}}, {{450, 150}}, {{100, 50}}, {{1000, 200}}, {{500, 200}}, {{200, 100}}, {{600, 500}}, {{200, 100}}, {{100, 20}}, {{500, 100}}, {{450, 150}}, {{100, 50}}, {{1000, 200}}, {{500, 200}}, {{200, 100}}, {{600, 500}}, {{200, 100}}, {{100, 20}}, {{500, 100}}, {{450, 150}}, {{100, 50}}, {{1000, 200}}, {{500, 200}}, {{200, 100}}, {{600, 500}}, {{200, 100}}}, []int{11150}},
			}

			for _, test := range testData {
				actual := main.CountProfit(test.Input)

				Expect(actual).NotTo(BeEmpty())
				Expect(actual).To(Equal(test.Expected))
			}

		})
	})

	When("Data is containing many branch in many month", func() {
		It("should return total profirm from many branch in many month", func() {
			var testData = []TestData{
				{[][][2]int{{{1000, 800}, {700, 500}, {100, 50}}, {{1000, 800}, {900, 200}, {500, 200}}, {{1000, 900}, {900, 200}, {500, 200}}}, []int{500, 1600, 650}},
				{[][][2]int{
					{{1000, 800}, {700, 500}, {100, 50}, {900, 200}, {500, 200}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{700, 500}, {1000, 800}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}, {100, 50}, {900, 200}, {500, 200}},
					{{1000, 800}, {900, 200}, {500, 200}, {700, 500}, {100, 50}, {500, 200}, {700, 500}, {1000, 800}, {900, 200}, {1000, 900}},
					{{1000, 800}, {700, 500}, {100, 50}, {900, 200}, {500, 200}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{700, 500}, {100, 50}, {900, 200}, {500, 200}, {1000, 800}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{1000, 900}, {900, 200}, {500, 200}, {900, 200}, {500, 200}, {700, 500}, {100, 50}, {500, 200}, {700, 500}, {1000, 800}},
					{{700, 500}, {100, 50}, {900, 200}, {500, 200}, {1000, 800}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{1000, 800}, {700, 500}, {100, 50}, {900, 200}, {500, 200}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{700, 500}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}, {100, 50}, {900, 200}, {500, 200}, {1000, 800}},
					{{700, 500}, {1000, 800}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}, {100, 50}, {900, 200}, {500, 200}},
					{{1000, 800}, {900, 200}, {500, 200}, {700, 500}, {100, 50}, {500, 200}, {700, 500}, {1000, 800}, {900, 200}, {1000, 900}},
					{{1000, 800}, {700, 500}, {100, 50}, {900, 200}, {500, 200}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{700, 500}, {100, 50}, {900, 200}, {500, 200}, {1000, 800}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{1000, 900}, {900, 200}, {500, 200}, {900, 200}, {500, 200}, {700, 500}, {100, 50}, {500, 200}, {700, 500}, {1000, 800}},
					{{700, 500}, {100, 50}, {900, 200}, {500, 200}, {1000, 800}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{1000, 900}, {900, 200}, {500, 200}, {900, 200}, {500, 200}, {700, 500}, {100, 50}, {500, 200}, {700, 500}, {1000, 800}},
					{{700, 500}, {100, 50}, {900, 200}, {500, 200}, {1000, 800}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{1000, 800}, {700, 500}, {100, 50}, {900, 200}, {500, 200}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
					{{700, 500}, {100, 50}, {900, 200}, {500, 200}, {1000, 800}, {700, 500}, {1000, 800}, {900, 200}, {700, 500}, {100, 50}},
				}, []int{3500, 5400, 6550, 8900, 5300, 3850, 2900, 9800, 5900, 2150}},
			}

			for _, test := range testData {
				actual := main.CountProfit(test.Input)

				Expect(actual).NotTo(BeEmpty())
				Expect(actual).To(Equal(test.Expected))
			}
		})
	})
})
